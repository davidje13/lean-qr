#!/usr/bin/env node
import{mode as e,correction as n,generate as r}from"../build/index.mjs";import{toSvgSource as o}from"../build/extras/svg.mjs";import{toPngBuffer as t}from"../build/extras/node_export.mjs";import{readError as s}from"../build/extras/errors.mjs";function i(e,n){return"0x"+e.toString(16).padStart(n.length,"0").toUpperCase()}function a(e,n){switch(e.type){case"string":return n;case"enum":if(!e.values.includes(n))throw new Error(`Unknown value ${n} for ${e.name}; expected: ${e.values.join(", ")}`);return n;case"int":{const r=Number.parseInt(n,10);if(String(r)!==n)throw new Error(`Value for ${e.name} must be an integer`);if(void 0!==e.min&&r<e.min)throw new Error(`Value for ${e.name} must be >= ${e.min}`);if(void 0!==e.max&&r>e.max)throw new Error(`Value for ${e.name} must be <= ${e.max}`);return r}case"hex":{let r=16;n.startsWith("0b")?(r=2,n=n.substring(2)):n.startsWith("0x")?n=n.substring(2):n.length===4*e.length&&(r=2);const o=Number.parseInt(n,r);if(o.toString(r).padStart(e.length*(2===r?4:1),"0")!==n.toLowerCase())throw new Error(`Value for ${e.name} must be a ${4*e.length}-bit integer in base 2 or 16`);if(void 0!==e.min&&o<e.min)throw new Error(`Value for ${e.name} must be >= ${i(e.min,e)}`);if(void 0!==e.max&&o>e.max)throw new Error(`Value for ${e.name} must be <= ${i(e.max,e)}`);return o}default:throw new Error(`Internal error parsing ${e.name}`)}}const m=new Map;m.set("auto",e.auto),m.set("numeric",e.numeric),m.set("alphanumeric",e.alphaNumeric),m.set("ascii",e.ascii),m.set("iso-8859-1",e.iso8859_1),m.set("shift-jis",e.shift_jis),m.set("utf8",e.utf8);const c=new Map;c.set("text-ansi-invert",{on:"\x1b[7m  \x1b[0m"}),c.set("text-ansi-bw",{on:"\x1b[40m  ",off:"\x1b[107m  ",lf:"\x1b[0m\n"}),c.set("text-ansi-wb",{on:"\x1b[107m  ",off:"\x1b[40m  ",lf:"\x1b[0m\n"}),c.set("text-box",{on:"\u2588\u2588"}),c.set("text-ascii",{});const f=[{id:"encoding",name:"encoding",short:"e",type:"enum",values:[...m.keys()],def:"auto",info:"Set the encoding type for the content"},{id:"minCor",name:"min-correction",short:"c",type:"enum",values:[...Object.keys(n)],def:"min",info:"Set the minimum error correction level"},{id:"maxCor",name:"max-correction",short:"C",type:"enum",values:[...Object.keys(n)],def:"max",info:"Set the maximum error correction level"},{id:"minVer",name:"min-version",short:"v",type:"int",min:1,max:40,def:1,info:"Set the minimum version (size)"},{id:"maxVer",name:"max-version",short:"V",type:"int",min:1,max:40,def:40,info:"Set the maximum version (size)"},{id:"padding",name:"padding",short:"p",type:"int",min:0,def:4,info:"Set the edge padding size"},{id:"mask",name:"mask",short:"m",type:"enum",values:["auto","0","1","2","3","4","5","6","7"],def:"auto",info:"Set the masking type (advanced usage)"},{id:"trailer",name:"trailer",short:"t",type:"hex",length:4,min:0,max:65535,def:60433,info:"Set the trailer data (advanced usage)"},{id:"format",name:"format",short:"f",type:"enum",values:[...c.keys(),"svg","png"],def:"text-ansi-invert",info:"Set the output format"},{id:"info",name:"info",short:"i",type:"presence",info:"Print meta information to stderr"},{id:"help",name:"help",short:"?",type:"presence",info:"Print documentation"}];try{const e=function(e,n){let r=2;const o={};for(e.forEach((({id:e,def:n})=>{o[e]=n}));r<n.length;++r){const t=n[r];if("--"===t){++r;break}if(t.startsWith("--")){let s=t.indexOf("=");-1===s&&(s=t.length);const i=t.slice(2,s),m=e.find((({name:e})=>e===i));if(!m)throw new Error(`Unknown option ${i}`);"presence"===m.type?o[m.id]=!0:o[m.id]=a(m,s<t.length?t.slice(s):n[++r])}else{if(!t.startsWith("-"))break;for(let s=1;s<t.length;++s){const i=t[s],m=e.find((({short:e})=>e===i));if(!m)throw new Error(`Unknown shorthand option ${i}`);if("presence"!==m.type){if("="===t[s+1]){o[m.id]=a(m,t.slice(s+2));break}o[m.id]=a(m,s<t.length-1?t.slice(s+1):n[++r]);break}o[m.id]=!0}}}return o.rest=n.slice(r).join(" "),o}(f,process.argv);e.help&&(p="lean-qr",d="CLI for generating a QR code",u=f,l="content",process.stdout.write(`${d}\n\n`),process.stdout.write(`Usage: ${p} [flags] [--] ${l}\n\n`),u.forEach((e=>{switch(process.stdout.write(`--${e.name} / -${e.short}\n\n`),process.stdout.write(`  ${e.info}\n`),e.type){case"enum":process.stdout.write(`\n  One of: ${e.values.join(", ")}\n`);break;case"int":process.stdout.write("\n  Integer"),void 0!==e.min&&process.stdout.write(` >=${e.min}`),void 0!==e.max&&process.stdout.write(` <=${e.max}`),process.stdout.write("\n");break;case"hex":process.stdout.write("\n  Hexadecimal value"),void 0!==e.min&&process.stdout.write(` >=${i(e.min,e)}`),void 0!==e.max&&process.stdout.write(` <=${i(e.max,e)}`),process.stdout.write("\n")}void 0!==e.def&&("hex"===e.type?process.stdout.write(`  Default: ${i(e.def,e)}\n`):process.stdout.write(`  Default: ${e.def}\n`)),process.stdout.write("\n\n")})),process.stdout.write("\n"),process.exit(0));const s=e.rest,h=m.get(e.encoding.toLowerCase());if(!h)throw new Error("Unknown encoding type");const w=h(s),v=Date.now(),x=r(w,{minCorrectionLevel:n[e.minCor],maxCorrectionLevel:n[e.maxCor],minVersion:e.minVer,maxVersion:e.maxVer,mask:"auto"===e.mask?null:Number(e.mask),trailer:e.trailer}),$=Date.now();let b;if("svg"===e.format){const n=o(x,{on:"black",off:"white",padX:e.padding,padY:e.padding,xmlDeclaration:!0});b=Date.now(),process.stdout.write(n+"\n")}else if("png"===e.format){const n=t(x,{on:[0,0,0],off:[255,255,255],scale:8,padX:e.padding,padY:e.padding});b=Date.now(),process.stdout.write(n)}else{if(!c.has(e.format))throw new Error("Unknown output format");{const n=x.toString({...c.get(e.format),padX:e.padding,padY:e.padding});b=Date.now(),process.stdout.write(n)}}e.info&&(process.stderr.write("Time taken:\n"),process.stderr.write(`  generate: ${$-v}ms\n`),process.stderr.write(`  format: ${b-$}ms\n`))}catch(e){process.stderr.write(`${s(e)}\n\n`),process.exit(1)}var p,d,u,l;
