#!/usr/bin/env node
import{mode as e,correction as t,generate as n}from"../build/index.js";import{toSvgSource as r}from"../build/extras/svg.js";import{shift_jis as o}from"../build/extras/jis.js";function i(e,t){switch(e.type){case"string":return t;case"enum":if(!e.values.includes(t))throw new Error(`Unknown value ${t} for ${e.name}; expected: ${e.values.join(", ")}`);return t;case"int":{const n=Math.round(Number(t));if(String(n)!==t)throw new Error(`Value for ${e.name} must be an integer`);if(void 0!==e.min&&n<e.min)throw new Error(`Value for ${e.name} must be >= ${e.min}`);if(void 0!==e.max&&n>e.max)throw new Error(`Value for ${e.name} must be <= ${e.max}`);return n}default:throw new Error(`Internal error parsing ${e.name}`)}}const s={modes:[e.numeric,e.alphaNumeric,e.ascii,e.iso8859_1,o,e.utf8]},a=new Map;a.set("auto",(t=>e.auto(t,s))),a.set("numeric",e.numeric),a.set("alphanumeric",e.alphaNumeric),a.set("ascii",e.ascii),a.set("iso-8859-1",e.iso8859_1),a.set("shift-jis",o),a.set("utf8",e.utf8);const m=new Map;m.set("text-ansi-invert",{on:"\x1b[7m  \x1b[0m"}),m.set("text-ansi-bw",{on:"\x1b[40m  ",off:"\x1b[107m  ",lf:"\x1b[0m\n"}),m.set("text-ansi-wb",{on:"\x1b[107m  ",off:"\x1b[40m  ",lf:"\x1b[0m\n"}),m.set("text-box",{on:"\u2588\u2588"}),m.set("text-ascii",{});const c=[{id:"encoding",name:"encoding",short:"e",type:"enum",values:[...a.keys()],def:"auto",info:"Set the encoding type for the content"},{id:"minCor",name:"min-correction",short:"c",type:"enum",values:[...Object.keys(t)],def:"min",info:"Set the minimum error correction level"},{id:"maxCor",name:"max-correction",short:"C",type:"enum",values:[...Object.keys(t)],def:"max",info:"Set the maximum error correction level"},{id:"minVer",name:"min-version",short:"v",type:"int",min:1,max:40,def:1,info:"Set the minimum version (size)"},{id:"maxVer",name:"max-version",short:"V",type:"int",min:1,max:40,def:40,info:"Set the maximum version (size)"},{id:"padding",name:"padding",short:"p",type:"int",min:0,def:4,info:"Set the edge padding size"},{id:"mask",name:"mask",short:"m",type:"enum",values:["auto","0","1","2","3","4","5","6","7"],def:"auto",info:"Set the masking type (advanced usage)"},{id:"format",name:"format",short:"f",type:"enum",values:[...m.keys(),"svg"],def:"text-ansi-invert",info:"Set the output format"},{id:"info",name:"info",short:"i",type:"presence",info:"Print meta information to stderr"},{id:"help",name:"help",short:"?",type:"presence",info:"Print documentation"}];try{const e=function(e,t){let n=2;const r={};for(e.forEach((({id:e,def:t})=>{r[e]=t}));n<t.length;++n){const o=t[n];if("--"===o){++n;break}if(o.startsWith("--")){let s=o.indexOf("=");-1===s&&(s=o.length);const a=o.slice(2,s),m=e.find((({name:e})=>e===a));if(!m)throw new Error(`Unknown option ${a}`);"presence"===m.type?r[m.id]=!0:r[m.id]=i(m,s<o.length?o.slice(s):t[++n])}else{if(!o.startsWith("-"))break;for(let s=1;s<o.length;++s){const a=o[s],m=e.find((({short:e})=>e===a));if(!m)throw new Error(`Unknown shorthand option ${a}`);if("presence"!==m.type){if("="===o[s+1]){r[m.id]=i(m,o.slice(s+2));break}r[m.id]=i(m,s<o.length-1?o.slice(s+1):t[++n]);break}r[m.id]=!0}}}return r.rest=t.slice(n).join(" "),r}(c,process.argv);e.help&&(d="lean-qr",f="CLI for generating a QR code",u=c,p="content",process.stdout.write(`${f}\n\n`),process.stdout.write(`Usage: ${d} [flags] [--] ${p}\n\n`),u.forEach((e=>{switch(process.stdout.write(`--${e.name} / -${e.short}\n\n`),process.stdout.write(`  ${e.info}\n`),e.type){case"enum":process.stdout.write(`\n  One of: ${e.values.join(", ")}\n`);break;case"int":process.stdout.write("\n  Integer"),void 0!==e.min&&process.stdout.write(` >=${e.min}`),void 0!==e.max&&process.stdout.write(` <=${e.max}`),process.stdout.write("\n")}void 0!==e.def&&process.stdout.write(`  Default: ${e.def}\n`),process.stdout.write("\n\n")})),process.stdout.write("\n"),process.exit(0));const o=e.rest,s=a.get(e.encoding.toLowerCase());if(!s)throw new Error("Unknown encoding type");const l=s(o),h=Date.now(),w=n(l,{minCorrectionLevel:t[e.minCor],maxCorrectionLevel:t[e.maxCor],minVersion:e.minVer,maxVersion:e.maxVer,mask:"auto"===e.mask?null:Number(e.mask)}),g=Date.now();let x;if("svg"===e.format){const t=r(w,{on:"black",off:"white",padX:e.padding,padY:e.padding,xmlDeclaration:!0});x=Date.now(),process.stdout.write(t+"\n")}else{if(!m.has(e.format))throw new Error("Unknown output format");{const t=w.toString({...m.get(e.format),padX:e.padding,padY:e.padding});x=Date.now(),process.stdout.write(t)}}e.info&&(process.stderr.write("Time taken:\n"),process.stderr.write(`  generate: ${g-h}ms\n`),process.stderr.write(`  format: ${x-g}ms\n`))}catch(e){process.stderr.write(`${e.message}\n\n`),process.exit(1)}var d,f,u,p;
